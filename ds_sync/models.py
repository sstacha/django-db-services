from django.db import models
from django.conf import settings
from django.core.validators import MaxValueValidator, MinValueValidator
from tagulous.models import TagTreeModel, TagModel, TagField, SingleTagField

log_level_choices = (
    (10, 'Debug'),
    (20, 'Info'),
    (30, 'Warning')
)


def get_connection_choices():
    return [
        (key, key)
        for key in list(settings.DATABASES)
    ]

# changing from TagTreeModel to TagModel for simplicity
class ConfigurationChannelTag(TagModel):
    """
    Channels or groups to place configurations in.
    Ex: sync all configurations in channel 'crm/customer' or 'crm/section' or 'crm'

    This should allow crons to be flexible setting up for various frequencies for different channels
    """
    class TagMeta:
        force_lowercase = True

    class Meta:
        verbose_name = "Sync Configuration Channel"


class SyncConfigurationManager(models.Manager):
    """
    Currently using one evaluation manager for all is_active stuff; split if need other specialized methods
    """
    def active(self):
        queryset = self.get_queryset()
        return queryset.filter(is_active=True)

    def disabled(self):
        queryset = self.get_queryset()
        return queryset.exclude(is_active=True)


class SyncConfiguration(models.Model):
    objects = SyncConfigurationManager()
    from_connection_name = models.CharField(max_length=255, choices=get_connection_choices(),
                                            verbose_name="from connection")
    to_connection_name = models.CharField(max_length=255, choices=get_connection_choices(),
                                          verbose_name="to connection")
    table_name = models.CharField(max_length=800, verbose_name="table", help_text="Table name to sync")
    pk_field_name = models.CharField(max_length=800, default='id', verbose_name="primary key",
                                     help_text="Primary key field name.  While this doesn't have to be a primary key "
                                               "it does have to be unique indexed to only return one row.")
    channels = TagField(
        to=ConfigurationChannelTag,
        blank=True,
        help_text="Allows syncing by group(s) of configurations.  "
                  "Ex: 'daily', 'weekly' or 'customer, daily'"
    )
    notes = models.TextField(max_length=2000, null=True, blank=True)
    is_active = models.BooleanField(default=True, verbose_name="active")
    log_level_override = models.PositiveSmallIntegerField(choices=log_level_choices, null=True, blank=True,
                                                          help_text="Alters the log level for the log output per sync")

    # modified_by = models.CharField(max_length=255, null=True, blank=True)
    # modified_date = models.DateTimeField(auto_now=True, editable=False)

    class Meta:
        ordering = ["-is_active", "from_connection_name", "to_connection_name"]
        unique_together = ['from_connection_name', 'to_connection_name', 'table_name']

    def __str__(self):
        return f"[{str(self.from_connection_name)}] -> [{str(self.to_connection_name)}] : {str(self.table_name)}"


class SyncRun(models.Model):
    sync = models.ForeignKey(SyncConfiguration, on_delete=models.CASCADE)
    start_date = models.DateTimeField(auto_now_add=True, editable=False)
    end_date = models.DateTimeField(null=True, blank=True, editable=False)
    has_succeeded = models.BooleanField(null=True)
    # msg = models.CharField(max_length=1024, null=True, blank=True)
    log = models.TextField(null=True, blank=True)

    class Meta:
        ordering = ["-end_date", "-start_date"]

    # uncomment if it becomes a problem were devs are editing records they shouldn't
    # def save(self, *args, **kwargs):
    #     if self.id:
    #         raise NotImplementedError("Editing not allowed; these are generated by running python manage.py sync")

    def __str__(self):
        return f"{str(self.sync)} ({str(self.start_date)} - {str(self.end_date)})"


class AlertCategoryTag(TagModel):
    """
    Channels or groups to place configurations in.
    Ex: sync all configurations in channel 'crm/customer' or 'crm/section' or 'crm'

    This should allow crons to be flexible setting up for various frequencies for different channels
    """
    class TagMeta:
        force_lowercase = True

    class Meta:
        verbose_name = "Sync Alert Category"
        verbose_name_plural = "Sync Alert Categories"


class SyncAlert(models.Model):
    sync = models.ForeignKey(SyncConfiguration, on_delete=models.CASCADE, null=True, blank=True)
    after_failure_cnt = models.PositiveSmallIntegerField(default=1,
                                                         validators=[
                                                             MaxValueValidator(25),
                                                             MinValueValidator(1)
                                                         ],
                                                         help_text="Number of failures before alert is triggered ("
                                                                   "1-25).")
    category = SingleTagField(
        to=AlertCategoryTag,
        blank=True,
        help_text="Single keyword category the alert can be assigned to for scheduling"
                  "Ex: 'daily' or 'weekly' or 'monthly'"
    )
    # frequency_minutes = models.PositiveIntegerField(default=1440,
    #                                                 help_text="How often to wait between alerts in minutes "
    #                                                           "(default 1 per 24hrs).  This also "
    #                                                           "depends on "
    #                                                           "how often the cron is run.  Any value less than the "
    #                                                           "cron "
    #                                                           "frequency will alert for every failure.")
    last_alert_date = models.DateTimeField(null=True, blank=True,
                                           help_text="Saved after each alert.  "
                                                     "Used to determine if new alerts are sent.")
    email_list = models.CharField(max_length=2048, null=True, blank=True,
                                  help_text="Comma separated list of email addresses to receive alert.")

    class Meta:
        ordering = ["sync", "category", "after_failure_cnt"]

    def __str__(self):
        return f"{str(self.sync)} {str(self.last_alert_date)}"
